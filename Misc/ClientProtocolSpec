

The following is the draft specification for the Server-Phone communication protocol

Definitions:
	Client: The iPhone/iPad device contacting the server
	ClientID: A unique per device identifier sent to the client from the server
	Server: Our crazy server doing *stuff*

Format:
	The formats use psuedo regular expression syntax to describe a format.
	Note that {n} indicates repetition and ()? indicates zero or one occurences of ()
	<Value> refers to a placeholder that should be replaced with an actual value,
	not a literal <Value>

	"(<Key>: <Value>\r\n)*" Refers to optional HTTP headers that are not needed for the protocol

Encoding:
	The protocol is a text based protocol, we will use ASCII encoding for simplicity.

	
HTTP Requests:
	Our format is basically HTTP with a custom JSON request/response body to convey protocol information.
	Use standard HTTP libraries to make requests, using <ServerName>/<MessageName> as the URL to request
		a message with a given name.

Song ID:
	Song IDs will never change.

Connection Behavior:
	Unless otherwise noted, the connection between the client and the server should
	be persistent and held open. Use the HTTP Connection: keep-alive" option when making requests.
	In the event of an unexpected disconnection between the client
	and the server, the connection should be reopened and the previous client ID
	should be reused for continued communication.

Connection Protocol:
	We will use TCP/HTTP over port <Decide Later>.


Client to Server messages:
	AUTHENTICATE_CLIENT:
		Description:
			Attempt to log in to the server
		Format:
			"POST authenticate HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>
			 \r\n
			 { "Pin": "<Pin>" }
		Remarks:

	REQUEST_SONG_LIST:
		Description:
			Sent to the server to request the current song list
		Format:
			"GET request_song_list HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 \r\n"
		Remarks:
	

	VOTE:
		Description:
			Sent to the server to vote on a song
		Format:
			"POST vote HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>\r\n
			 \r\n
			 {"ClientID": "<ClientID>", "SongID": SongID}"
		Remarks:
 
	LIKE:
		Description:
			Sent to the server to like the current song
		Format:
			"POST like HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>\r\n
			 \r\n
			 {"ClientID": "<ClientID>", "SongID": <SongID>}"
		Remarks:
	

	DISLIKE:
		Description:
			Sent to the server to dislike the current song
		Format:
			"POST dislike HTTP/1.1\r\n
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>\r\n
			 \r\n
			 {"ClientID": "<Client>", "SongID": "<SongID>"}"
		Remarks:


	REQUEST_UPDATE:
		Description:
			Request any new updates from the server.
		Format:
			"GET request_update HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 \r\n"
		Remarks:
			This request should be made using "long-polling"
			i.e. Start HTTP connection with large timeout value, and the server
				will hold the connection open and won't send a response until
				an update becomes available to send to the client.
				Best to use asynchronous HTTP libraries for this purpose, and set high timeout.

	REQUEST_LIKE_UPDATE:
		Description:
			Ask the server to send a like update
		Format:
			"GET request_like_update HTTP/1.1\r\n
			 (<Key>: <Value>\r\n)*
			 \r\n"
		Remarks:

	REQUEST_VOTE_UPDATE:
		Description:
			Ask the server to send a vote update
		Format:
			"GET request_vote_update HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 \r\n"
		Remarks:

	REQUEST_SONG_UPDATE:
		Description:
			Ask the server to send a song update
		Format:
			"GET request_song_update HTTP/1.1\r\n
			(<Key>: <Value>\r\n)*
			 \r\n"
		Remarks:
		
		


Server to Client messages:
	AUTHENTICATED:
		Description:
			Response to a successful authenicate message from the client
		Format:
			"HTTP/1.1 200 Authenticated\r\n
			 (<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>\r\n
			 \r\n
			 { "ClientID": "<ClientID>"}"
		Remarks:
			

	SONG_UPDATE:
		Description:
			Indicates the current state of song playback.
			The particular message will very likely be changed.
		Format:
			"HTTP/1.1 200 Update Available\r\n
			 (<Key>: <Value>\r\n)*
			 SongID: <SongID>\r\n
			 Song-Name: <Song Name>\r\n
			 Song-Artist: <Artist>\r\n
			 Song-Album: <Album>\r\n
			 Song-Length: <Length>\r\n
			 Song-Status: (Playing|Paused)\r\n
			 Song-Position: <Playback Position\r\n
			(Content-Type: image/<ImageType>\r\n
			 Content-Length: <ImageLength>\r\n)?
			 \r\n
			(Binary image data if ImageLength > 0 and ImageType available)"
		Remarks:
			Playback position is formatted as an integer indicating the number of milliseconds
			the song has played up to the point of the update.
			The photo image data will be given in the response body
			while other information will be given in the header
		Notes:
			The App should cache the Photo for a given song because
			the server may decide to save bandwidth by only sending
			photos when the song changes, not for status updates

	VOTE_UPDATE:
		Description:
			Indicates the current voting results.
		Format:
			"HTTP/1.1 200 Update Available\r\n
			(<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>\r\n\r\n
			 {"votes": [({"SongID": "<Votes>"})*]}"
		Remarks:
		

	LIKE_UPDATE:
		Description:
			Indicates the current balance of likes/dislikes for a song
		Format:
			"HTTP/1.1 200 Update Available\r\n
			(<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 \r\n
			 { "likes": [({"SongID": <SongID>, "Likes": <Likes>, "Dislikes": <Dislikes>, "Balance": <Balance>}*]}
		Remarks:
			Likes and dislikes are integers, while balance is a double in the interval [-1,1]
			Likes and dislikes are the raw data, while balance has been computed by the server.
		Note:
			If the <SongID> doesn't match the song ID the app thinks is playing,
			it would be prudent to refresh that information

	SONG_LIST:
		Description:
			A listing of the songs currently in the set list
		Format:
			"HTTP/1.1 200 List Available\r\n
			(<Key>: <Value>\r\n)*
			 Content-Type: application/json\r\n
			 Content-Length: <JsonLength>\r\n
			 \r\n
			 {"songs": [({"SongID": <SongID>,
						  "SongName": "<SongName>",
						  "SongArtist": "<SongArtist>",
						  "SongAlbum": "<SongAlbum>",
						  "Votes": <Votes>})*]
			 }"			
		Remarks:

	FAILED:
		Description:
			A message to indicate to the client that an operation failed
		Format:
			"HTTP/1.1 <ErrorCode!=200> <Explaination>\r\n
			 (<Key>: <Value>\r\n)*
			 \r\n"
		Remarks:
		

